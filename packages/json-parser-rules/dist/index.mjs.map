{
  "version": 3,
  "sources": ["../src/json-parser-rules.ts"],
  "sourcesContent": ["\nexport type Maybe<Type> = (Type | undefined);\n\nexport interface Options {\n  rules: ReviverRule[];\n  parser?: Maybe<ParserFunc>;\n}\n\nexport interface ReviverRule {\n  pattern: (string | string[]);\n  reviver: Reviver;\n}\n\nexport type Reviver = (\n  (context: ReviverContext) => any\n);\n\nexport interface ReviverContext {\n  value: any;\n  source: string;\n  path: string;\n}\n\nexport type ParserFunc<Type = any> = (\n  text: string,\n  reviver?: Maybe<InternalReviver>\n) => Type;\n\nexport type InternalReviver = (\n  key: string,\n  value: any,\n  context: InternalReviverContext\n) => any;\n\nexport interface InternalReviverContext {\n  source: string;\n  keys: string[];\n}\n\ntype CompiledRule = [Matcher, Reviver];\ntype Matcher = (RegExp | string);\n\n\nexport function parseJsonByRules<Type = any>(\n  source: string,\n  options: Options\n\n): Type {\n\n  const compiledRules = compileRules(options.rules);\n\n  const parser: ParserFunc = (\n    options.parser ??\n    <ParserFunc> JSON.parse\n  );\n\n  return parser(source, (key, value, context) => {\n\n    const { keys, source } = context;\n\n    const path = keys.join('.');\n\n    const reviver = findReviver(path);\n\n    if (!reviver) {\n      return value;\n    }\n\n    return reviver({\n      value,\n      source,\n      path,\n    });\n\n  });\n\n\n  function findReviver(path: string): Maybe<Reviver> {\n\n    for (const [matcher, reviver] of compiledRules) {\n\n      if (typeof matcher === 'string') {\n        if (matcher === path) {\n          return reviver;\n        }\n      } else {\n        if (matcher.test(path)) {\n          return reviver;\n        }\n      }\n\n    }\n\n    return undefined;\n\n  }\n\n  function compileRules(\n    rules: ReviverRule[]\n\n  ): CompiledRule[] {\n\n    const compiledRules: CompiledRule[] = [];\n\n    for (const rule of rules) {\n\n      const patterns = (Array.isArray(rule.pattern)\n        ? rule.pattern\n        : [rule.pattern]\n      );\n\n      for (const pattern of patterns) {\n        const matcher = compilePattern(pattern);\n        compiledRules.push([matcher, rule.reviver]);\n      }\n\n    }\n\n    return compiledRules;\n\n  }\n\n  function compilePattern(pattern: string): (RegExp | string) {\n\n    let parts = [];\n    let isRegExp = false;\n\n    for (const token of pattern.split('.')) {\n      if (token === '**') {\n        parts.push('.*');\n        isRegExp = true;\n      } else if (token.includes('*')) {\n        parts.push(token.replace(/\\*/g, '[^\\\\.]*?'));\n        isRegExp = true;\n      } else {\n        parts.push(token);\n      }\n    }\n\n    if (isRegExp) {\n\n      const rePattern = (\n        '^' + parts.join('\\\\.') + '$'\n      );\n\n      return new RegExp(rePattern);\n\n    } else {\n\n      return pattern;\n\n    }\n\n  }\n\n}\n"],
  "mappings": ";AA2CO,SAAS,iBACd,QACA,SAEM;AAEN,QAAM,gBAAgB,aAAa,QAAQ,KAAK;AAEhD,QAAM,SACJ,QAAQ,UACK,KAAK;AAGpB,SAAO,OAAO,QAAQ,CAAC,KAAK,OAAO,YAAY;AAE7C,UAAM,EAAE,MAAM,QAAAA,QAAO,IAAI;AAEzB,UAAM,OAAO,KAAK,KAAK,GAAG;AAE1B,UAAM,UAAU,YAAY,IAAI;AAEhC,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AAEA,WAAO,QAAQ;AAAA,MACb;AAAA,MACA,QAAAA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EAEH,CAAC;AAGD,WAAS,YAAY,MAA8B;AAEjD,eAAW,CAAC,SAAS,OAAO,KAAK,eAAe;AAE9C,UAAI,OAAO,YAAY,UAAU;AAC/B,YAAI,YAAY,MAAM;AACpB,iBAAO;AAAA,QACT;AAAA,MACF,OAAO;AACL,YAAI,QAAQ,KAAK,IAAI,GAAG;AACtB,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IAEF;AAEA,WAAO;AAAA,EAET;AAEA,WAAS,aACP,OAEgB;AAEhB,UAAMC,iBAAgC,CAAC;AAEvC,eAAW,QAAQ,OAAO;AAExB,YAAM,WAAY,MAAM,QAAQ,KAAK,OAAO,IACxC,KAAK,UACL,CAAC,KAAK,OAAO;AAGjB,iBAAW,WAAW,UAAU;AAC9B,cAAM,UAAU,eAAe,OAAO;AACtC,QAAAA,eAAc,KAAK,CAAC,SAAS,KAAK,OAAO,CAAC;AAAA,MAC5C;AAAA,IAEF;AAEA,WAAOA;AAAA,EAET;AAEA,WAAS,eAAe,SAAoC;AAE1D,QAAI,QAAQ,CAAC;AACb,QAAI,WAAW;AAEf,eAAW,SAAS,QAAQ,MAAM,GAAG,GAAG;AACtC,UAAI,UAAU,MAAM;AAClB,cAAM,KAAK,IAAI;AACf,mBAAW;AAAA,MACb,WAAW,MAAM,SAAS,GAAG,GAAG;AAC9B,cAAM,KAAK,MAAM,QAAQ,OAAO,UAAU,CAAC;AAC3C,mBAAW;AAAA,MACb,OAAO;AACL,cAAM,KAAK,KAAK;AAAA,MAClB;AAAA,IACF;AAEA,QAAI,UAAU;AAEZ,YAAM,YACJ,MAAM,MAAM,KAAK,KAAK,IAAI;AAG5B,aAAO,IAAI,OAAO,SAAS;AAAA,IAE7B,OAAO;AAEL,aAAO;AAAA,IAET;AAAA,EAEF;AAEF;",
  "names": ["source", "compiledRules"]
}
